#!/usr/bin/php
<?php

/**
 * Smart Asset Manager
 *
 * Manage local and remote CSS assets.
 */


/**
 * Print usage information, then exit.
 */
function usage() {
    echo <<<EOF
usage: ${argv[0]} <pack1> [ <packn> ]
EOF;
    exit(1);
}


/**
 * Print a message.
 *
 * @param string $tpl The template string
 * @param array $vars Variables to use for substitition
 */
function _log(string $tpl, array $vars = []) {
    foreach ($vars as $k => $v) {
        $tpl = str_replace('{'.$k.'}', $v, $tpl);
    }
    echo $tpl."\n";
}


/**
 * Print error message.
 *
 * @param string $tpl The template string
 * @param array $vars Variables to use for substitution
 */
function error(string $tpl, array $vars = []) {
    _log("error: $tpl", $vars);
}


/**
 * Print debug message
 *
 * @param string $level The debug level
 * @param string $tpl The template string
 * @param array $vars Variables to use for substitution
 */
function debug(int $level, string $tpl, array $vars = []) {
    global $options;
    if ($level <= $options['log_level']) _log("debug: $tpl", $vars);
}


/**
 * Execute a command using proc_open/proc_close
 */
function pexec(string $cmd, string $path, array $env = []) {
    $desc = [
        0 => ['pipe', 'r'],
        1 => ['pipe', 'w'],
        2 => ['pipe', 'w']
    ];

    debug(1, "running {cmd} in {path}", [ 'cmd' => $cmd, 'path' => $path ]);

    $proc = proc_open($cmd, $desc, $pipes, $path, $env);

    if ($proc === false) {
        debug(1, 'failed to execute command: {cmd}', [ 'cmd' => $cmd ]);
        return;
    }

    $out = stream_get_contents($pipes[1]);
    $err = stream_get_contents($pipes[2]);

    return [
        'rc' => proc_close($proc),
        'out' => $out,
        'err' => $err
    ];
}


/**
 * Set option
 *
 * @param string $optdef Option definition
 * @param array $options The options array
 */
function set_opt(string $optdef, &$options) {
    list($opt, $val) = explode(' ', $optdef);
    $options[$opt] = $val;
}


function substitute(string $str, array $vars): string {
    foreach ($vars as $k => $v) {
        $str = str_replace('{'.$k.'}', $v, $str);
    }
    return $str;
}


/**
 * Sanitize URL/path name for use as directory name
 */
function sanitize(string $res): string {
    $res = preg_replace('#^https://((.*:|).+@|)#', '', $res);
    $res = preg_replace('#/#', '_', $res);
    return $res;
}


/**
 * Fetch a remote or local GIT repository
 *
 * @param string $asset The asset definition
 * @param string $cwd The current working directory for the process
 */
function fetch_git(string $asset, string $cwd) {
    if (empty($asset)) {
        error('empty asset definition');
        return;
    }

    $parts = preg_split('/\s+/', $asset);

    if (!isset($parts[1])) {
        error('missing commit reference');
        return;
    }

    if (!isset($parts[2])) {
        error('missing asset path');
        return;
    }

    $src = array_shift($parts);
    $ref = array_shift($parts);

    if (!file_exists('remote')) {
        mkdir('remote');
    }

    $dst = 'remote/'.sanitize($src);
    $fetch = true;

    /*
     * If the repo already exists locally, check that it contains the commit,
     * and if it doesn't, then delete and prepare to fetch it again.
     */
    if (file_exists($dst)) {
        $res = pexec("/usr/bin/git rev-parse $ref", $dst);
        if ($res['rc'] !== 0) {
            pexec("/bin/rm -r $dst", $cwd);
        } else {
            $fetch = false;
        }
    }

    if ($fetch) {
        $res = pexec("/usr/bin/git clone $src $dst", $cwd); 
        if ($res['rc'] !== 0) {
            error("failed to clone {src} to {dst}: {err} ({rc})", [
                'src' => $src,
                'dst' => $dst,
                'err' => str_replace("\n", '_', $res['err']),
                'rc' => $res['rc']
            ]);
            return;
        }
    }

    $res = pexec("/usr/bin/git checkout $ref", $dst);
    if ($res['rc'] !== 0) {
        error("failed to checkout {ref}: {err} ({rc})", [
            'ref' => $ref,
            'err' => str_replace("\n", '_', $res['err']),
            'rc' => $res['rc']
        ]);
        return;
    }

    $ret = [];
    foreach ($parts as $path) {
        $ret[] = "$dst/$path";
    }

    return $ret;
}


/**
 * Fetch a remote asset over HTTPS
 *
 * @param string $asset The asset definition
 * @param string $cwd The current working directory for the process
 */
function fetch_https(string $asset, string $cwd) {
    $parts = explode(' ', $asset);

    if (!isset($parts[1])) {
        error('missing checksum');
        return;
    }

    list($url, $checksum) = $parts;

    if (!file_exists('remote')) {
        mkdir('remote');
    }

    $dst = 'remote/'.sanitize($url);
    $fetch = true;

    if (file_exists($dst) && strpos(sha1($dst), $checksum) === 0) {
        $fetch = false;
    }

    if ($fetch) {
        $rh = @fopen($url, 'r');
        if (!$rh) {
            error('failed to read from {url}', [ 'url' => $url ]);
            return;
        }

        $lh = @fopen($dst, 'w');
        if (!$lh) {
            error('failed to open {file}', [ 'file' => $dst ]);
            return;
        }

        flock($lh, LOCK_EX);
        while (!feof($rh)) {
            fwrite($lh, fread($rh, 4096 * 16));
        }
        flock($lh, LOCK_UN);
        fclose($lh);
        fclose($rh);

        $sum = sha1_file($dst);
        if (strpos($sum, $checksum) !== 0) {
            error('checksum mismatch: expected {exp}, got {got}', [
                'exp' => $checksum,
                'got' => $sum
            ]);
            return false;
        }
    }

    return [ $dst ];
}


/**
 * Fetch an asset local to the project
 *
 * @param string $asset The asset definition
 * @param string $cwd The current working directory 
 */
function fetch_local(string $asset, string $cwd) {
    if (!file_exists($asset)) {
        error('asset not found: {asset}', [ 'asset' => $asset ]);
        return;
    }

    return [ $asset ];
}


$defaults = [
    'log_level' => 0,
    'suffix' => '.min.css',
    'target' => '{pack}{suffix}'
];

$ac = count($argv);
for ($i=1; $i<$ac; $i++) {
    $pack = $argv[$i];

    if (!file_exists($pack)) {
        error("pack file doesn't exist: {pack}", ['pack' => $pack]);
        exit(1);
    }

    $cwd = dirname($pack);
    $pack = basename($pack);
    chdir($cwd);

    $options = array_merge($defaults, []);
    $options['pack'] = $pack;

    $cf = @fopen("$pack.tmp", "w");
    flock($cf, LOCK_EX);

    $assets = explode("\n", file_get_contents(basename($pack)));

    $lc = count($assets);
    for ($l=0; $l<$lc; $l++) {
        $asset = $assets[$l];

        if (preg_match('/(^#|^$|^\s+$)/', $asset)) {
            debug(2, '{file}:{line} empty line or comment', [
                'file' => $pack,
                'line' => $l
            ]);
            continue;
        }

        while (substr($assets[$l+1], 0, 1) === ' ') {
            debug(2, 'escape line break, asset continues on next line');
            $next = $assets[++$l];
            $asset .= ' '.preg_replace('/^\s+/', '', $next);
        }

        $paths = [];

        $asset = substitute($asset, $options);

        if (substr($asset, 0, 4) === 'set ') {
            set_opt(substr($asset, 4), $options);
            continue;
        } elseif (substr($asset, 0, 4) === 'git ') {
            $paths = fetch_git(substr($asset, 4), $cwd);
        } elseif (substr($asset, 0, 8) === 'https://') {
            $paths = fetch_https($asset, $cwd);
        } else {
            $paths = fetch_local($asset, $cwd);
        }

        if (count($paths) === 0) {
            error('{file}:{line} returned empty path', [
                'file' => $pack,
                'line' => $l,
            ]);
            exit(1);
        }

        foreach ($paths as $path) {
            $af = @fopen($path, 'r');

            if (!$af) {
                error('failed to open {file} for reading, is the asset path correct?', [
                    'file' => $path
                ]);
                exit(1);
            }

            flock($af, LOCK_SH);

            while (!feof($af)) {
                fwrite($cf, fread($af, 4096 * 16));
            }

            flock($af, LOCK_UN);
            fclose($af);
        }

    }

    flock($cf, LOCK_UN);
    fclose($cf);

    if (isset($options['post_processor'])) {
        debug(1, 'running post processor: {pp}', [ 'pp' => $options['post_processor'] ]);

        $desc = [
            0 => array('pipe', 'r'),
            1 => array('file', "$pack.tmp.out", 'w'),
            2 => array('pipe', 'w')
        ];
        $cmd = $options['post_processor'];
        $proc = proc_open($cmd, $desc, $pipes, $cwd);

        if ($proc === false) {
            debug(1, 'failed to execute command: {cmd}', [ 'cmd' => $cmd ]);
            exit(1);
        }

        $if = @fopen("$pack.tmp", 'r');
        if ($if === false) {
            error('failed to open file for reading: {file}', [ 'file' => "$pack.tmp" ]);
            exit(1);
        }

        flock($if, LOCK_SH);

        while (!feof($if)) {
            fwrite($pipes[0], fread($if, 4096 * 16));
        }

        flock($if, LOCK_UN);
        fclose($if);

        proc_close($proc);

        rename("$pack.tmp.out", "$pack.tmp");

    }

    $target = $options['target'];
    foreach ($options as $k => $v) {
        $target = str_replace('{'.$k.'}', $v,  $target);
    }

    rename("$pack.tmp", $target);

}

